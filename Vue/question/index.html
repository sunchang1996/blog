<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 面试题总结 | 阿畅的博客</title>
    <meta name="generator" content="VuePress 1.4.1">
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?831c09097cdcc6b28d4d8b82e7a2603b";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
    <meta name="description" content="JavaScript，Vue，React，Webpack，HTML，CSS等技术分享">
    <meta name="author" content="achang">
    <meta name="keywords" content="前端全栈知识体系， JavaScript， Vue， react， webpack， HTML， CSS，JavaScript算法">
    <link rel="preload" href="/blog/assets/css/0.styles.8141bd51.css" as="style"><link rel="preload" href="/blog/assets/js/app.2a9e1d26.js" as="script"><link rel="preload" href="/blog/assets/js/2.b5c945b0.js" as="script"><link rel="preload" href="/blog/assets/js/13.61f1338a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.1c9cb128.js"><link rel="prefetch" href="/blog/assets/js/100.d9c496b9.js"><link rel="prefetch" href="/blog/assets/js/101.2dbefcdd.js"><link rel="prefetch" href="/blog/assets/js/102.f49cba67.js"><link rel="prefetch" href="/blog/assets/js/11.c5365335.js"><link rel="prefetch" href="/blog/assets/js/12.20c384c5.js"><link rel="prefetch" href="/blog/assets/js/14.f2c80a95.js"><link rel="prefetch" href="/blog/assets/js/15.fb46f9ec.js"><link rel="prefetch" href="/blog/assets/js/16.3c06bc72.js"><link rel="prefetch" href="/blog/assets/js/17.6b9fcc1c.js"><link rel="prefetch" href="/blog/assets/js/18.56735f47.js"><link rel="prefetch" href="/blog/assets/js/19.969cecdd.js"><link rel="prefetch" href="/blog/assets/js/20.a65e4dc5.js"><link rel="prefetch" href="/blog/assets/js/21.0e66da52.js"><link rel="prefetch" href="/blog/assets/js/22.f4fdebc1.js"><link rel="prefetch" href="/blog/assets/js/23.44d8c7d7.js"><link rel="prefetch" href="/blog/assets/js/24.e5051be4.js"><link rel="prefetch" href="/blog/assets/js/25.dcc79434.js"><link rel="prefetch" href="/blog/assets/js/26.00c15f45.js"><link rel="prefetch" href="/blog/assets/js/27.355b2a79.js"><link rel="prefetch" href="/blog/assets/js/28.68fd4985.js"><link rel="prefetch" href="/blog/assets/js/29.d84cc35f.js"><link rel="prefetch" href="/blog/assets/js/3.75a46af6.js"><link rel="prefetch" href="/blog/assets/js/30.3fb21238.js"><link rel="prefetch" href="/blog/assets/js/31.50b37b70.js"><link rel="prefetch" href="/blog/assets/js/32.869bfdb4.js"><link rel="prefetch" href="/blog/assets/js/33.b28c193b.js"><link rel="prefetch" href="/blog/assets/js/34.395eb3af.js"><link rel="prefetch" href="/blog/assets/js/35.c9607dd7.js"><link rel="prefetch" href="/blog/assets/js/36.406eefe2.js"><link rel="prefetch" href="/blog/assets/js/37.b2df7963.js"><link rel="prefetch" href="/blog/assets/js/38.9aacdff1.js"><link rel="prefetch" href="/blog/assets/js/39.34efcf53.js"><link rel="prefetch" href="/blog/assets/js/4.6b6fa8d7.js"><link rel="prefetch" href="/blog/assets/js/40.4d190766.js"><link rel="prefetch" href="/blog/assets/js/41.dcb0dea2.js"><link rel="prefetch" href="/blog/assets/js/42.4751f5ea.js"><link rel="prefetch" href="/blog/assets/js/43.1c65769a.js"><link rel="prefetch" href="/blog/assets/js/44.e2617f11.js"><link rel="prefetch" href="/blog/assets/js/45.284f7399.js"><link rel="prefetch" href="/blog/assets/js/46.4bfc2e64.js"><link rel="prefetch" href="/blog/assets/js/47.18b91d63.js"><link rel="prefetch" href="/blog/assets/js/48.0eb5b63f.js"><link rel="prefetch" href="/blog/assets/js/49.040a5bb1.js"><link rel="prefetch" href="/blog/assets/js/5.4f36be39.js"><link rel="prefetch" href="/blog/assets/js/50.280a74de.js"><link rel="prefetch" href="/blog/assets/js/51.1bff542f.js"><link rel="prefetch" href="/blog/assets/js/52.21278878.js"><link rel="prefetch" href="/blog/assets/js/53.bc5246ce.js"><link rel="prefetch" href="/blog/assets/js/54.da98e62c.js"><link rel="prefetch" href="/blog/assets/js/55.41da599e.js"><link rel="prefetch" href="/blog/assets/js/56.0e5b1be4.js"><link rel="prefetch" href="/blog/assets/js/57.b3233b28.js"><link rel="prefetch" href="/blog/assets/js/58.d3aefbaf.js"><link rel="prefetch" href="/blog/assets/js/59.b9cec5f9.js"><link rel="prefetch" href="/blog/assets/js/6.5101726b.js"><link rel="prefetch" href="/blog/assets/js/60.0dc2c6a9.js"><link rel="prefetch" href="/blog/assets/js/61.4f15fd19.js"><link rel="prefetch" href="/blog/assets/js/62.22e1fa3a.js"><link rel="prefetch" href="/blog/assets/js/63.42f92443.js"><link rel="prefetch" href="/blog/assets/js/64.56bf1bf7.js"><link rel="prefetch" href="/blog/assets/js/65.9f9ba7cc.js"><link rel="prefetch" href="/blog/assets/js/66.a0149269.js"><link rel="prefetch" href="/blog/assets/js/67.958096a6.js"><link rel="prefetch" href="/blog/assets/js/68.ce31b0f8.js"><link rel="prefetch" href="/blog/assets/js/69.e0b63645.js"><link rel="prefetch" href="/blog/assets/js/7.f595f157.js"><link rel="prefetch" href="/blog/assets/js/70.04ba63ca.js"><link rel="prefetch" href="/blog/assets/js/71.14a3e361.js"><link rel="prefetch" href="/blog/assets/js/72.fe00762e.js"><link rel="prefetch" href="/blog/assets/js/73.56200c06.js"><link rel="prefetch" href="/blog/assets/js/74.a609f591.js"><link rel="prefetch" href="/blog/assets/js/75.4bb00fd2.js"><link rel="prefetch" href="/blog/assets/js/76.81ee7781.js"><link rel="prefetch" href="/blog/assets/js/77.a36daa4b.js"><link rel="prefetch" href="/blog/assets/js/78.76314acb.js"><link rel="prefetch" href="/blog/assets/js/79.23710e07.js"><link rel="prefetch" href="/blog/assets/js/8.3a49e8ed.js"><link rel="prefetch" href="/blog/assets/js/80.79f1e427.js"><link rel="prefetch" href="/blog/assets/js/81.09e15374.js"><link rel="prefetch" href="/blog/assets/js/82.1457d6e3.js"><link rel="prefetch" href="/blog/assets/js/83.c037e760.js"><link rel="prefetch" href="/blog/assets/js/84.61a7ef93.js"><link rel="prefetch" href="/blog/assets/js/85.ef000657.js"><link rel="prefetch" href="/blog/assets/js/86.7bbe8636.js"><link rel="prefetch" href="/blog/assets/js/87.0b020f6e.js"><link rel="prefetch" href="/blog/assets/js/88.6d380c7b.js"><link rel="prefetch" href="/blog/assets/js/89.9a22d7e4.js"><link rel="prefetch" href="/blog/assets/js/9.4705cb4e.js"><link rel="prefetch" href="/blog/assets/js/90.e1d50ec8.js"><link rel="prefetch" href="/blog/assets/js/91.3f1edaa3.js"><link rel="prefetch" href="/blog/assets/js/92.6fa69482.js"><link rel="prefetch" href="/blog/assets/js/93.dc85e9dc.js"><link rel="prefetch" href="/blog/assets/js/94.2f42b212.js"><link rel="prefetch" href="/blog/assets/js/95.4bf7ddff.js"><link rel="prefetch" href="/blog/assets/js/96.ad15f572.js"><link rel="prefetch" href="/blog/assets/js/97.8615c32e.js"><link rel="prefetch" href="/blog/assets/js/98.df4af9cf.js"><link rel="prefetch" href="/blog/assets/js/99.6bb9e42c.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.8141bd51.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">阿畅的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/basics/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/interview/" class="nav-link">
  js 面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/algorithm/" class="nav-link">
  js 数据结构与算法
</a></li></ul></div></div><div class="nav-item"><a href="/blog/js-algorithm/" class="nav-link">
  js 算法与数据结构
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="react" class="dropdown-title"><span class="title">react</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/react/combat/" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/blog/react/taro/" class="nav-link">
  taro
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue" class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Vue/principle/" class="nav-link">
  Vue 原理
</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/combat/" class="nav-link">
  Vue 项目实战
</a></li></ul></div></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="nodejs" class="dropdown-title"><span class="title">nodejs</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/node/sequelize/" class="nav-link">
  sequelize
</a></li></ul></div></div><div class="nav-item"><a href="/blog/css-html/" class="nav-link">
  CSS+HTML
</a></div><div class="nav-item"><a href="/blog/http/" class="nav-link">
  http
</a></div><div class="nav-item"><a href="https://github.com/sunchang1996/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/basics/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/interview/" class="nav-link">
  js 面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/algorithm/" class="nav-link">
  js 数据结构与算法
</a></li></ul></div></div><div class="nav-item"><a href="/blog/js-algorithm/" class="nav-link">
  js 算法与数据结构
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="react" class="dropdown-title"><span class="title">react</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/react/combat/" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/blog/react/taro/" class="nav-link">
  taro
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue" class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Vue/principle/" class="nav-link">
  Vue 原理
</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/combat/" class="nav-link">
  Vue 项目实战
</a></li></ul></div></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="nodejs" class="dropdown-title"><span class="title">nodejs</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/node/sequelize/" class="nav-link">
  sequelize
</a></li></ul></div></div><div class="nav-item"><a href="/blog/css-html/" class="nav-link">
  CSS+HTML
</a></div><div class="nav-item"><a href="/blog/http/" class="nav-link">
  http
</a></div><div class="nav-item"><a href="https://github.com/sunchang1996/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue 实战</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Vue/combat/" class="sidebar-link">vue-awesome-swiper 自定义分页器</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue 原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Vue/principle/" class="sidebar-link">手写 Vue 响应式框架 （学习响应式原理）</a></li><li><a href="/blog/Vue/principle/defineproperty.html" class="sidebar-link">模拟 Vue2.x 双向数据监听</a></li><li><a href="/blog/Vue/principle/proxy.html" class="sidebar-link">Vue 3.x 数据响应式原理</a></li><li><a href="/blog/Vue/principle/observer.html" class="sidebar-link">学习 Vue 中观察者模式</a></li><li><a href="/blog/Vue/principle/subscribe.html" class="sidebar-link">模拟 Vue 自定义事件（订阅发布模式）</a></li><li><a href="/blog/Vue/principle/vnode.html" class="sidebar-link">Vue3.x 组件的渲染过程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue 面试题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Vue/question/" class="active sidebar-link">Vue 面试题总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/Vue/question/#什么是-mvvm" class="sidebar-link">什么是 MVVM</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-是如何实现数据双向绑定的" class="sidebar-link">Vue 是如何实现数据双向绑定的</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-中的-computed-和-watch-的区别-？" class="sidebar-link">Vue 中的 computed 和 watch 的区别 ？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-中-computed-是如何实现的" class="sidebar-link">Vue 中 computed 是如何实现的</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-nexttick-的原理" class="sidebar-link">Vue $nextTick 的原理</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#spa-单页面的理解，它的优缺点分别是什么-？" class="sidebar-link">SPA 单页面的理解，它的优缺点分别是什么 ？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-是如何对数组方法进行变异的？-push-pop-splice-等" class="sidebar-link">Vue 是如何对数组方法进行变异的？ push , pop splice 等</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#v-show-与-v-if-的区别？" class="sidebar-link">v-show 与 v-if 的区别？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#class-与-style-如何动态绑定？" class="sidebar-link">Class 与 Style 如何动态绑定？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#怎么理解-vue-的单向数据流？" class="sidebar-link">怎么理解 Vue 的单向数据流？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#直接给数组某项赋值，vue-能检测到变化吗？" class="sidebar-link">直接给数组某项赋值，Vue 能检测到变化吗？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#谈谈对-vue-生命周期的理解-？" class="sidebar-link">谈谈对 Vue 生命周期的理解 ？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-的父组件和子组件生命周期钩子函数执行顺序" class="sidebar-link">Vue 的父组件和子组件生命周期钩子函数执行顺序</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#在哪个生命周期内调用异步请求？" class="sidebar-link">在哪个生命周期内调用异步请求？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#在什么阶段才能访问操作-dom" class="sidebar-link">在什么阶段才能访问操作 DOM</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#父组件监听到子组件的生命周期吗？" class="sidebar-link">父组件监听到子组件的生命周期吗？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#谈谈对-keep-alive-的了解" class="sidebar-link">谈谈对 keep-alive 的了解</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#组件中-data-为什么是一个函数" class="sidebar-link">组件中 data 为什么是一个函数</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#v-model-的原理" class="sidebar-link">v-model 的原理</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-组件间通信有哪几种方式" class="sidebar-link">Vue 组件间通信有哪几种方式</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#使你用过-vuex-吗？" class="sidebar-link">使你用过 Vuex 吗？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#使用过-vue-ssr-吗？-说说-ssr" class="sidebar-link">使用过 Vue SSR 吗？ 说说 SSR</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-router-路由模式有几种？" class="sidebar-link">vue-router 路由模式有几种？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-router-中常用的-hash-和-history-路由模式的实现原理？" class="sidebar-link">vue-router 中常用的 hash 和 history 路由模式的实现原理？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#v-model-原理" class="sidebar-link">v-model 原理</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-框架怎么实现对象和数组的监听" class="sidebar-link">Vue 框架怎么实现对象和数组的监听</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#proxy-与-object-defineproperty-优劣对比" class="sidebar-link">Proxy 与 Object.defineProperty 优劣对比</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-怎么用-vm-set-解决对象新增属性不能影响的问题" class="sidebar-link">Vue 怎么用 vm.$set() 解决对象新增属性不能影响的问题</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#虚拟-dom-的优缺点" class="sidebar-link">虚拟 DOM 的优缺点</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#虚拟-dom-实现原理" class="sidebar-link">虚拟 DOM 实现原理?</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#vue-中的-key-有什么作用？" class="sidebar-link">Vue 中的 key 有什么作用？</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#双向绑定和-vuex-是否冲突" class="sidebar-link">双向绑定和 Vuex 是否冲突</a></li><li class="sidebar-sub-header"><a href="/blog/Vue/question/#在-vue-中，子组件为何不可以修改父组件的-prop，如果修改了，vue-如何监听到修改的并给出警告的" class="sidebar-link">在 Vue 中，子组件为何不可以修改父组件的 Prop，如果修改了，Vue 如何监听到修改的并给出警告的</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-面试题总结"><a href="#vue-面试题总结" class="header-anchor">#</a> Vue 面试题总结</h1> <h2 id="什么是-mvvm"><a href="#什么是-mvvm" class="header-anchor">#</a> 什么是 MVVM</h2> <ul><li>MVVM - 数据驱动视图
<ul><li>不在操作 DOM，只需要改数据</li> <li>M -&gt; <font color="red">model</font>   v -&gt; <font color="red">view</font>  vm -&gt; <font color="red">viewModel 连接层 </font></li> <li>M -&gt; 存JavaScript对象  V -&gt; DOM  VM - vue</li> <li>传统组件，只是静态渲染，更新还要依赖于操作 DOM</li></ul></li></ul> <h3 id="view-层"><a href="#view-层" class="header-anchor">#</a> View 层</h3> <ul><li>View 是视图层，也是用户界面。前端主要由HTML 和 CSS 构建</li></ul> <blockquote><p>vue template 可以理解为 View</p></blockquote> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>showMessage()<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="model-层"><a href="#model-层" class="header-anchor">#</a> Model 层</h3> <ul><li>Model 是数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;url&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/server/data/api&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;res&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;success&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;baidu&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;domain&quot;</span><span class="token operator">:</span> <span class="token string">&quot;www.baidu.com&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="viewmodel-层"><a href="#viewmodel-层" class="header-anchor">#</a> ViewModel 层</h3> <ul><li>是由前端人员组织生成和维护的视图数据层。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 用于描述视图状态   </span>
    message<span class="token operator">:</span> <span class="token string">'Hello Vue!'</span><span class="token punctuation">,</span> 
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// Ajax 获取 Model 层的数据</span>
    <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      url<span class="token operator">:</span> <span class="token string">'/server/data/api'</span><span class="token punctuation">,</span>
      <span class="token function">success</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        vm<span class="token punctuation">.</span>message <span class="token operator">=</span> res<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>  
    <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      <span class="token function">alert</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="vue-是如何实现数据双向绑定的"><a href="#vue-是如何实现数据双向绑定的" class="header-anchor">#</a> Vue 是如何实现数据双向绑定的</h2> <ul><li>Vue 数据双向绑定主要是指：<font color="red">数据变化更新视图，视图变化更新数据</font> <ul><li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li> <li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li></ul></li> <li>View 变化更新 Data，可以通过事件监听的方式实现，所以<font color="red"> Vue 的数据双向绑定的工作主要根据如果让 Data 变化更新 View。</font></li></ul> <h3 id="vue-实现双向绑定的原理"><a href="#vue-实现双向绑定的原理" class="header-anchor">#</a> Vue 实现双向绑定的原理</h3> <ol><li><p><font color="red">实现一个监听器 Observer：</font> <font color="#0000FF">对数据对象进行遍历，包括子属性对象属性，利用 Object.defineProperty 对属性都加上 setter 和 getter。这样之后，给这个对象某个属性赋值，就会触发它的 setter ，那么就能监听到数据变化。</font></p></li> <li><p><font color="red">实现一个解析器 Compile：</font> <font color="#0000FF">解析 Vue 模板指令，将模板中的变量都替换成数据，然后渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据发生变动，收到通知调用更新函数进行更新.</font></p></li> <li><p><font color="red">实现一个订阅者 Watcher：</font> <font color="#0000FF">Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要任务是订阅 Observer 中的属性值变化的消息，当收到变化时，触发解析器 Compile 中对应的更新函数。</font></p></li> <li><p><font color="red">实现一个订阅器 Dep：</font> <font color="#0000FF">订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</font></p></li></ol> <h2 id="vue-中的-computed-和-watch-的区别-？"><a href="#vue-中的-computed-和-watch-的区别-？" class="header-anchor">#</a> Vue 中的 computed 和 watch 的区别 ？</h2> <ul><li>功能上：<font color="red">computed 是计算属性，也就是依赖其它的属性计算后所得出的值。</font> <font color="#f28500">watch是去监听一个值的变化，然后执行相应的函数</font></li> <li>使用上：<font color="red">computed 中的函数必须使用 return 返回；</font>，<font color="#f28500">watch 的回调里面传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要return </font></li> <li>性能上：<font color="red">computed 中的函数所依赖的属性没有发生变化，那么调用当前函数的时候回从缓存中读取</font>，<font color="#f28500">而 watch 在每次监听值发生变化的时候都会执行回调，支持对属性的深度监听。</font></li> <li>场景上：computed 当一个属性受多个属性影响的时候，例如：商品结算；watch：当一条数据影响多个数据的时候。例如：分页</li></ul> <h2 id="vue-中-computed-是如何实现的"><a href="#vue-中-computed-是如何实现的" class="header-anchor">#</a> Vue 中 computed 是如何实现的</h2> <ul><li><font color="red"> computed 内部实现了一个惰性的 watcher</font>，在实例化的时候不会去求值，<font color="#f28500">其内部通过 dirty 属性标记计算属性是否需要重新求值</font>。当 computed 依赖的任意状态发生改变，都会通知这个惰性的 watcher，让它把 dirty 属性设置为 true，所以，当再次读取这个计算属性的时候，就会重新去求值。</li></ul> <blockquote><p><font color="red">惰性的watcher 计算属性在创建时不会去求值的，是在使用时去求值</font>。</p></blockquote> <h2 id="vue-nexttick-的原理"><a href="#vue-nexttick-的原理" class="header-anchor">#</a> Vue $nextTick 的原理</h2> <ul><li>Vue 在默认情况下，<font color="red">每次触发某个数据的 setter 方法后，对应的 watcher 对象其实会被 push 进入一个队列 Queue 中，在下一个 tick 的时候将这个队列 queue 全部拿出来 run （Watcher 对象的一个方法，用来触发 patch 操作） 一遍。</font></li> <li><font color="red">nextTick(callback) 优先使用生成 微任务的 promise.then 和 MutationObserver，</font>如果浏览器不支持，才用 setImmediate ， setTimeout 等替代。</li> <li>如果一个变量更新多次，例如：number ++ 从 0 到 100，只需要更新一个视图即可，就是 0 变成 100，<font color="red">在同一 watcher 在同一个 tick 的时候应该只被执行一次，也就是说队列中不应该出现重复的 watcher 对象。用id 来标记每个 watcher 对象。</font></li></ul> <h2 id="spa-单页面的理解，它的优缺点分别是什么-？"><a href="#spa-单页面的理解，它的优缺点分别是什么-？" class="header-anchor">#</a> SPA 单页面的理解，它的优缺点分别是什么 ？</h2> <ul><li>sing-page application 仅在 web 页面初始化时加载响应的 HTML JavaScript 和 css。一旦页面加载完成，<font color="red">SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内部的变换，UI与用户的交互，避免页面的重新加载。</font></li></ul> <h3 id="优点："><a href="#优点：" class="header-anchor">#</a> 优点：</h3> <ol><li>用户体验好，快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于1的优点，SPA 相对对服务器的压力小；</li> <li>前后端分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ol> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点:</h3> <ol><li>初次加载消耗多，问了实现单页 web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 同一加载，部分页面按需加载</li> <li>前进后退路由管理： 由于单页面应用在一个页面上显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理。</li> <li>SEO 难度较大： 由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上有着天然的劣势。</li></ol> <h2 id="vue-是如何对数组方法进行变异的？-push-pop-splice-等"><a href="#vue-是如何对数组方法进行变异的？-push-pop-splice-等" class="header-anchor">#</a> Vue 是如何对数组方法进行变异的？ push , pop splice 等</h2> <ul><li>Vue2 中 用 <font color="red">Object.defineProperty 对数据进行拦截，而这个方法并不能监听数组内部变化，数组长度变化等，所以对数组进行 hack， 让Vue检测到内部的变化.</font></li> <li><font color="#f28500">本质上就是从写了原型上的方法，在变异的方法中 加入了自定义的逻辑，最后也调用了真正的数组的方法。</font></li></ul> <blockquote><p>Object.defineProperty 的缺陷导致如果直接改变数组下标是无法 hack 的，因此，Vue 提供了 $set 的方式。新版的 Vue3 中使用了 proxy 的方式，可以支持监听数组，但也带来了兼容性的问题。</p></blockquote> <h2 id="v-show-与-v-if-的区别？"><a href="#v-show-与-v-if-的区别？" class="header-anchor">#</a> v-show 与 v-if 的区别？</h2> <h3 id="v-if"><a href="#v-if" class="header-anchor">#</a> v-if</h3> <ul><li>是真正的条件渲染，因为它会保证在切换过程中条件内的时间监听和子组件适当的被销毁重建；也是惰性的；如果在初始化条件渲染时为 false，则什么都不做，直到条件第一次为真时才会开始渲染条件块。</li></ul> <h3 id="v-show"><a href="#v-show" class="header-anchor">#</a> v-show</h3> <ul><li>不管什么条件，元素总是被渲染，并且用 CSS display 属性记性切换。</li></ul> <blockquote><p>v-if 使用与在运行时很少改变条件，不需要频繁切换条件的场景； v-show 则适用于需要非常频繁切换条件的场景。</p></blockquote> <h2 id="class-与-style-如何动态绑定？"><a href="#class-与-style-如何动态绑定？" class="header-anchor">#</a> Class 与 Style 如何动态绑定？</h2> <h3 id="class"><a href="#class" class="header-anchor">#</a> Class</h3> <ul><li>可以通过对象语法和数组语法进行动态绑定
<ul><li>对象</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>div <span class="token operator">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;{ active: isActive}&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
data<span class="token operator">:</span> <span class="token punctuation">{</span>
  isActive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>数组</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>div <span class="token operator">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;[isActive ? activeClass : '', defaultClass]&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
data<span class="token operator">:</span> <span class="token punctuation">{</span>
  activeClass<span class="token operator">:</span> <span class="token string">'active'</span><span class="token punctuation">,</span>
  defaultClass<span class="token operator">:</span> <span class="token string">'text-default'</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul> <h3 id="style"><a href="#style" class="header-anchor">#</a> Style</h3> <ul><li>也可以通过对象语法和数组语法进行动态绑定：
<ul><li>对象：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>div <span class="token operator">:</span>style<span class="token operator">=</span><span class="token string">&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
data<span class="token operator">:</span> <span class="token punctuation">{</span>
  activeColor<span class="token operator">:</span> <span class="token string">'blud'</span><span class="token punctuation">,</span>
  fontSize<span class="token operator">:</span> <span class="token number">26</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>数组语法</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token operator">&lt;</span>div <span class="token operator">:</span>style<span class="token operator">=</span><span class="token string">&quot;[styleColor, styleSize]&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    styleColor<span class="token operator">:</span> <span class="token punctuation">{</span>
      color<span class="token operator">:</span> <span class="token string">'blud'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    styleSize<span class="token operator">:</span><span class="token punctuation">{</span>
      fontSize<span class="token operator">:</span><span class="token string">'26px'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul> <h2 id="怎么理解-vue-的单向数据流？"><a href="#怎么理解-vue-的单向数据流？" class="header-anchor">#</a> 怎么理解 Vue 的单向数据流？</h2> <ul><li><p>所有的 props 都是通过父组件的 props 之间形成一个 <font color="red">单向下行绑定</font>：父 props 的更新会向下流动到子组件中，但反过来不行，这样是为了防止子组件意外改变父级组件的状态，从而导致数据流没办法理解。</p></li> <li><p><font color="red">父组件更新时，子组件中所有的 props 都将会刷新拿到最新的值，子组件不能改变父组件的 props，会抛出警告。</font> <font color="#f28500">子组件修改父组件，只能通过 $emit 派发一个自定义时间，父组件接收后，由父组件修改。</font></p></li></ul> <h2 id="直接给数组某项赋值，vue-能检测到变化吗？"><a href="#直接给数组某项赋值，vue-能检测到变化吗？" class="header-anchor">#</a> 直接给数组某项赋值，Vue 能检测到变化吗？</h2> <ul><li>由于JavaScript 的显示，Vue 不能检测一下方式的数组变化：
<ul><li>当利用索引直接修改数组每一项的值时： list[index] = newValue</li> <li>当你修改数组的长度时：list.length = newLength</li></ul></li></ul> <blockquote><p>为了解决这个问题，<font color="red">Vue 提供了 $set 的方式修改，或者使用 Vue封装好的几种数组的方式，例如 splice，因为这是 Object.defineProperty 的缺点，Vue3中使用 proxy 解决了这个问题。</font></p></blockquote> <h2 id="谈谈对-vue-生命周期的理解-？"><a href="#谈谈对-vue-生命周期的理解-？" class="header-anchor">#</a> 谈谈对 Vue 生命周期的理解 ？</h2> <ul><li>生命周期是什么 ？
<ul><li>Vue 实例有一个完整的 生命周期，从<font color="red">开始创建、初始化数据、编译模板、挂载 DOM、渲染、更新、渲染、卸载等一系列过程，成为生命周期。</font></li></ul></li></ul> <h3 id="各个生命周期的作用"><a href="#各个生命周期的作用" class="header-anchor">#</a> 各个生命周期的作用</h3> <ol><li>beforeCreate   <font color="red"> 组件实例被创建之初，组件的属性生效之前</font></li> <li>created         <font color="red">组件实例已经完全出创建，属性也绑定，但是真实 DOM 没有生成，$el 还不可以用</font></li> <li>beforeMount     <font color="red">在挂载开始之前被调用，相关的render函数首次被调用</font></li> <li>mounted         <font color="red">el 被新创建的 vm.$el 替换，并挂载实例上去调动该钩子</font></li> <li>beforeUpdate    <font color="red">组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</font></li> <li>update          <font color="red">组件数据更新之后</font></li> <li>activated       <font color="red">keep-alive 专属，组件被激活时调用</font></li> <li>deactivated     <font color="red">keep-alive 专属，组件被销毁时调用</font></li> <li>beforeDestory   <font color="red">组件销毁前调用</font></li> <li>destroyed      <font color="red">组件销毁后调用</font></li></ol> <h2 id="vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#vue-的父组件和子组件生命周期钩子函数执行顺序" class="header-anchor">#</a> Vue 的父组件和子组件生命周期钩子函数执行顺序</h2> <h3 id="加载渲染过程"><a href="#加载渲染过程" class="header-anchor">#</a> 加载渲染过程</h3> <ul><li>生命周期 - <font color="#f28500">创建是从外到内的，渲染是从内到外的</font></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token operator">-</span> 先创建 父组件的 created
  <span class="token operator">-</span> 在创建 子组件的 created
  <span class="token operator">-</span> 在渲染 子组件的 mounted
  <span class="token operator">-</span> 然后是 父组件的 mounted
  <span class="token operator">-</span> 父组件 before update
  <span class="token operator">-</span> 子组件 before update
  <span class="token operator">-</span> 子组件 updated
  <span class="token operator">-</span> 父组件 updated
  <span class="token operator">-</span> 父组件 beforeDestroy
  <span class="token operator">-</span> 子组件 beforeDestroy
  <span class="token operator">-</span> 子组件 destoryed
  <span class="token operator">-</span> 父组件 destoryed
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="在哪个生命周期内调用异步请求？"><a href="#在哪个生命周期内调用异步请求？" class="header-anchor">#</a> 在哪个生命周期内调用异步请求？</h2> <ul><li>在 钩子函数 created 、beforeMount、mounted 中进行调用，因为<font color="#f28500">在这三个钩子函数中，data 已经创建，可以将服务器点的数据返回进行赋值。</font></li></ul> <h2 id="在什么阶段才能访问操作-dom"><a href="#在什么阶段才能访问操作-dom" class="header-anchor">#</a> 在什么阶段才能访问操作 DOM</h2> <ul><li>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以可以在 mounted 中访问到 DOM。</li></ul> <h2 id="父组件监听到子组件的生命周期吗？"><a href="#父组件监听到子组件的生命周期吗？" class="header-anchor">#</a> 父组件监听到子组件的生命周期吗？</h2> <ul><li>有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// Parent.vue</span>
<span class="token operator">&lt;</span>Child @mounted<span class="token operator">=</span><span class="token string">&quot;doSomething&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    
<span class="token comment">// Child.vue</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&quot;mounted&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="谈谈对-keep-alive-的了解"><a href="#谈谈对-keep-alive-的了解" class="header-anchor">#</a> 谈谈对 keep-alive 的了解</h2> <ul><li>keep-alive 是 Vue 内置的一个组件，<font color="#f28500">可以使用包含的组件保留状态，避免重复渲染</font> <ol><li>一般结合路由和动态组件一起使用，用于缓存组件</li> <li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li> <li>对应两个钩子函数 <font color="#f28500">activated</font> 和 <font color="#f28500">deactivated</font> ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ol></li></ul> <h2 id="组件中-data-为什么是一个函数"><a href="#组件中-data-为什么是一个函数" class="header-anchor">#</a> 组件中 data 为什么是一个函数</h2> <ul><li><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p></li> <li><p><font color="#f28500">因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，</font>如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p></li></ul> <h2 id="v-model-的原理"><a href="#v-model-的原理" class="header-anchor">#</a> v-model 的原理</h2> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>something<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
相当于
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> @input<span class="token operator">=</span><span class="token string">&quot;$emit('change', $event.target.value)&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  model<span class="token operator">:</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token string">'text'</span><span class="token punctuation">,</span>
    event<span class="token operator">:</span> <span class="token string">'change'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    text<span class="token operator">:</span> String
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="vue-组件间通信有哪几种方式"><a href="#vue-组件间通信有哪几种方式" class="header-anchor">#</a> Vue 组件间通信有哪几种方式</h2> <ul><li>父子组件通信，隔代组件通信、兄弟组件通信</li></ul> <h4 id="props-emit-父子组件通信"><a href="#props-emit-父子组件通信" class="header-anchor">#</a> props / $emit 父子组件通信</h4> <h4 id="ref-与-parent-children-父子组件通信"><a href="#ref-与-parent-children-父子组件通信" class="header-anchor">#</a> ref 与 $parent / $children  父子组件通信</h4> <ul><li>ref： 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就是组件实例</li> <li>$parent / $children 访问 父 / 子 实例</li></ul> <h4 id="emit-on-父子、隔代、兄弟组件通信"><a href="#emit-on-父子、隔代、兄弟组件通信" class="header-anchor">#</a> $emit / $on  父子、隔代、兄弟组件通信</h4> <h4 id="attrs-listeners-隔代组件通信"><a href="#attrs-listeners-隔代组件通信" class="header-anchor">#</a> $attrs / $listeners  隔代组件通信</h4> <ul><li>$attrs：包含了父作用域中不被 prop 所识别（且获取）的特性绑定 （class 和 style 除外）当一个组件没有申明任何 prop 时，这里会包含所有副作用的绑定 （class 和 style 除外），可以通过 $attrs 传入内部组件。通常配合</li> <li>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件</li></ul> <h4 id="provide-inject-适用于隔代组件通信"><a href="#provide-inject-适用于隔代组件通信" class="header-anchor">#</a> provide / inject 适用于隔代组件通信</h4> <ul><li>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</li> <li>我自己一般那它用来刷新当前页面。</li></ul> <h4 id="vuex-适用于-父子、隔代、兄弟组件通信"><a href="#vuex-适用于-父子、隔代、兄弟组件通信" class="header-anchor">#</a> Vuex 适用于 父子、隔代、兄弟组件通信</h4> <ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
<ul><li>Vuex 的状态存储是响应式的。当组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也就拿到最新的数据。</li> <li>改变 store 中的状态唯一途径就是提交（commit）mutation。这能是我们方便跟踪每一个状态的变化。</li></ul></li></ul> <h2 id="使你用过-vuex-吗？"><a href="#使你用过-vuex-吗？" class="header-anchor">#</a> 使你用过 Vuex 吗？</h2> <ul><li>主要包含一下几种模块：
<h4 id="state"><a href="#state" class="header-anchor">#</a> State</h4> <ul><li>定义了应用状态的数据结构，可以在这里设置默认的初始化状态。</li></ul> <h4 id="getter"><a href="#getter" class="header-anchor">#</a> Getter</h4> <ul><li>允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性中。</li></ul> <h4 id="mutation"><a href="#mutation" class="header-anchor">#</a> Mutation</h4> <ul><li>是唯一更改 store 中状态的方法，且必须是同步函数。</li></ul> <h4 id="action"><a href="#action" class="header-anchor">#</a> Action</h4> <ul><li>用于提交 mutation，而不是直接变更状态，可以任何异步操作。</li></ul> <h4 id="module"><a href="#module" class="header-anchor">#</a> Module</h4> <ul><li>允许将单一的 Store 拆分为多个 store 且同时保持在单一的状态数中。</li></ul></li></ul> <h2 id="使用过-vue-ssr-吗？-说说-ssr"><a href="#使用过-vue-ssr-吗？-说说-ssr" class="header-anchor">#</a> 使用过 Vue SSR 吗？ 说说 SSR</h2> <ul><li>SSR 将 Vue 在客户端将标签渲染成HTML 片段的工作放到了服务端完成，服务端形成的 HTML 片段直接返回给客户端这个过程，叫做服务端渲染。</li></ul> <h3 id="服务端渲染的有点："><a href="#服务端渲染的有点：" class="header-anchor">#</a> 服务端渲染的有点：</h3> <ol><li><p>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取并不会等待异步完成后再去抓取结果，所以在 SPA 中抓取不到页面 Ajax 的请求内容，而 SSR 是结果从服务端渲染，返回时已经渲染好的页面（数据也包含在内），所以搜索引擎爬取可以抓到渲染好的页面;</p></li> <li><p>更快的内容到达时间（首屏加载更快）：SPA 等待所有 Vue 编译后的 js 文件都要下载完成后，才会进行页面的渲染，需要等待一段时间，SSR 直接由服务端渲染好页面直接返回显示，无需等待下载js 过程再去渲染，所以 SSR 更快。</p></li></ol> <h3 id="服务端渲染的缺点："><a href="#服务端渲染的缺点：" class="header-anchor">#</a> 服务端渲染的缺点：</h3> <ol><li>更多的开发条件限制： 只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</li> <li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</li> <li>更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ol> <h2 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="header-anchor">#</a> vue-router 路由模式有几种？</h2> <ul><li><p>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</p></li> <li><p>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</p></li> <li><p>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p></li></ul> <h2 id="vue-router-中常用的-hash-和-history-路由模式的实现原理？"><a href="#vue-router-中常用的-hash-和-history-路由模式的实现原理？" class="header-anchor">#</a> vue-router 中常用的 hash 和 history 路由模式的实现原理？</h2> <h3 id="hash-模式的实现原理"><a href="#hash-模式的实现原理" class="header-anchor">#</a> hash 模式的实现原理</h3> <ul><li>早期的前端路由基于 location.hash 实现的。</li> <li>hash 路由模式的实现主要基于下面几种特性：
<ol><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li> <li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li> <li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li> <li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ol></li></ul> <h3 id="history-模式的实现原理"><a href="#history-模式的实现原理" class="header-anchor">#</a> history 模式的实现原理</h3> <ul><li>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>history 路由模式的实现主要基于存在下面几种特性：</li></ul> <ol><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li> <li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li> <li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ol> <h2 id="v-model-原理"><a href="#v-model-原理" class="header-anchor">#</a> v-model 原理</h2> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>something<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
相当于
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>$emit('change', $event.target.value)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  model<span class="token operator">:</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token string">'text'</span><span class="token punctuation">,</span>
    event<span class="token operator">:</span> <span class="token string">'change'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    text<span class="token operator">:</span> String
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="vue-框架怎么实现对象和数组的监听"><a href="#vue-框架怎么实现对象和数组的监听" class="header-anchor">#</a> Vue 框架怎么实现对象和数组的监听</h2> <ul><li>可能都知道使用 Object.defineProperty() 对数据进行劫持，但它是怎么对整个对象进行劫持的，看它的源码</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token comment">/**
   * Observe a list of Array items.
   */</span>
  <span class="token function">observeArray</span> <span class="token punctuation">(</span><span class="token parameter">items<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// observe 功能为监测数据的变化</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * 对属性进行递归遍历
   */</span>
  <span class="token keyword">let</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// observe 功能为监测数据的变化</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li><font color="red">它是利用遍历数组和递归遍历对象的方式，从而达到利用 Object.defineProperty() 对对象和部分数组的监听。</font></li></ul> <h2 id="proxy-与-object-defineproperty-优劣对比"><a href="#proxy-与-object-defineproperty-优劣对比" class="header-anchor">#</a> Proxy 与 Object.defineProperty 优劣对比</h2> <ul><li><p>Proxy 的优势如下:</p> <ol><li>Proxy <font color="red">可以直接监听对象而非属性；</font></li> <li>Proxy <font color="red">可以直接监听数组的变化；</font></li> <li>Proxy <font color="red">有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</font></li> <li>Proxy <font color="red">返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</font></li> <li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ol></li> <li><p>Object.defineProperty 的优势如下:</p> <ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。</li></ul></li></ul> <h2 id="vue-怎么用-vm-set-解决对象新增属性不能影响的问题"><a href="#vue-怎么用-vm-set-解决对象新增属性不能影响的问题" class="header-anchor">#</a> Vue 怎么用 vm.$set() 解决对象新增属性不能影响的问题</h2> <ul><li><p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)  来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p></li> <li><p>查看对应的 Vue 源码：vue/src/core/instance/index.js</p></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> any<span class="token punctuation">,</span> val<span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>
  <span class="token comment">// target 为数组  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 利用数组的splice变异方法触发响应式  </span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// key 已经存在，直接修改属性值  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment">// target 本身就不是响应式数据, 直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 对属性进行响应式处理</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><ul><li>根据源码可知，vm.$set 的实现原理是：
<ul><li><font color="red">如果目标是数组，直接使用数组的 splice 方法触发响应式.</font></li> <li><font color="#0000FF">如果目标是对象，会先判断属性是否存在，对象是否是响应式，如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）。</font></li></ul></li></ul> <h2 id="虚拟-dom-的优缺点"><a href="#虚拟-dom-的优缺点" class="header-anchor">#</a> 虚拟 DOM 的优缺点</h2> <h4 id="优点：-2"><a href="#优点：-2" class="header-anchor">#</a> 优点：</h4> <ol><li><p><font color="red">保证性能下限：</font>框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但相比起直接操作 DOM 性能要好很多，因为框架的虚拟 DOM 至少可以保证你不需要手动优化的情况下，依然可以提供不错的性能，保证性能下限；</p></li> <li><p><font color="red">无需手动操作 DOM：</font>只要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和数据双向绑定，帮我们可预期的方式更新视图，提高开发效率。</p></li> <li><p><font color="red">跨平台：</font>虚拟 DOM 本质上是 JavaScript 对象，而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便跨平台操作，例如服务器渲染</p></li></ol> <h4 id="缺点："><a href="#缺点：" class="header-anchor">#</a> 缺点：</h4> <ul><li><font color="red">无法进行极致优化：</font> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但是一些性能要求极高的应用中虚拟 DOM 无法进行针对性的机制优化。</li></ul> <h2 id="虚拟-dom-实现原理"><a href="#虚拟-dom-实现原理" class="header-anchor">#</a> 虚拟 DOM 实现原理?</h2> <ol><li>用 JavaScript 对象模拟真实 DOM 数, 对真实 DOM 进行抽象;</li> <li>diff 算法 比较两颗虚拟 DOM 数的差异；</li> <li>pach 算法 将虚拟 DOM对象的差异应用到真正的 DOM 数。</li></ol> <h2 id="vue-中的-key-有什么作用？"><a href="#vue-中的-key-有什么作用？" class="header-anchor">#</a> Vue 中的 key 有什么作用？</h2> <ul><li><p>作用是：<font color="red">key 是为 VUe 中 vnode 的唯一标记，通过这个 key，使 diff 操作可以更准确，更快速。</font></p></li> <li><p>更准确：<font color="red">因为带 key 就不是 就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况，所以会更准确。</font></p></li> <li><p>更快速：<font color="red">利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。</font></p></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createKeyToOldIdx</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> beginIdx<span class="token punctuation">,</span> endIdx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> key
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> map
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="双向绑定和-vuex-是否冲突"><a href="#双向绑定和-vuex-是否冲突" class="header-anchor">#</a> 双向绑定和 Vuex 是否冲突</h2> <ul><li>在严格模式下，直接使用是会有冲突。</li></ul> <h4 id="怎么开启严格模式"><a href="#怎么开启严格模式" class="header-anchor">#</a> 怎么开启严格模式</h4> <ul><li>开启严格模式，仅需在创建 store 的时候传入 strict：true</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  strict<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><font color="red">在严格模式下，无论何时发生了状态变更且不是右 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</font></li></ul> <blockquote><p>不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。</p></blockquote> <h4 id="严格模式同时使用-v-model-和-vuex"><a href="#严格模式同时使用-v-model-和-vuex" class="header-anchor">#</a> 严格模式同时使用 v-model 和 Vuex</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;obj.message&quot;</span><span class="token operator">&gt;</span>
computed<span class="token operator">:</span> <span class="token punctuation">{</span>
  message<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">set</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'updateMessage'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>message
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token constant">UPDATE_MESSAGE</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>message <span class="token operator">=</span> v<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
actions<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">update_message</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'UPDATE_MESSAGE'</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><ul><li>这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会视图直接修改 obj.message。 而严格模式中，由于修改不在 mutation 函数中执行的，会抛出一个错误。</li></ul> <h4 id="使用-vuex-解决这个问题"><a href="#使用-vuex-解决这个问题" class="header-anchor">#</a> 使用 Vuex 解决这个问题</h4> <ul><li>给 <code>&lt;input&gt;</code>中绑定 value，然后侦听 input 或者 change 事件，在事件回调中调用一个方法:</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>updateMessage<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>computed<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">message</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>message
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
methods<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">updateMessage</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'updateMessage'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">updateMessage</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>message <span class="token operator">=</span> message
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="使用双向绑定解决这个问题"><a href="#使用双向绑定解决这个问题" class="header-anchor">#</a> 使用双向绑定解决这个问题</h4> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>computed<span class="token operator">:</span> <span class="token punctuation">{</span>
  message<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>message
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'updateMessage'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="在-vue-中，子组件为何不可以修改父组件的-prop，如果修改了，vue-如何监听到修改的并给出警告的"><a href="#在-vue-中，子组件为何不可以修改父组件的-prop，如果修改了，vue-如何监听到修改的并给出警告的" class="header-anchor">#</a> 在 Vue 中，子组件为何不可以修改父组件的 Prop，如果修改了，Vue 如何监听到修改的并给出警告的</h2> <h4 id="子组件为何不可以修改父组件传递的prop"><a href="#子组件为何不可以修改父组件传递的prop" class="header-anchor">#</a> 子组件为何不可以修改父组件传递的prop</h4> <ul><li>因为为 Vue 是单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。</li></ul> <h4 id="如果修改了，vue-是如何监控到属性的修改并给出警告的"><a href="#如果修改了，vue-是如何监控到属性的修改并给出警告的" class="header-anchor">#</a> 如果修改了，Vue 是如何监控到属性的修改并给出警告的</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hyphenatedKey <span class="token operator">=</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReservedAttribute</span><span class="token punctuation">(</span>hyphenatedKey<span class="token punctuation">)</span> <span class="token operator">||</span>
      config<span class="token punctuation">.</span><span class="token function">isReservedAttr</span><span class="token punctuation">(</span>hyphenatedKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token string">&quot;\&quot;&quot;</span> <span class="token operator">+</span> hyphenatedKey <span class="token operator">+</span> <span class="token string">&quot;\&quot; is a reserved attribute and cannot be used as component prop.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">defineReactive$$1</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isUpdatingChildComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token string">&quot;Avoid mutating a prop directly since the value will be &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;overwritten whenever the parent component re-renders. &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;Instead, use a data or computed property based on the prop's &quot;</span> <span class="token operator">+</span>
        <span class="token string">&quot;value. Prop being mutated: \&quot;&quot;</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">&quot;\&quot;&quot;</span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><ul><li>在 initProps 的时候，在 defineReactive 时通过判断环境是否在开发环境，如果在开发环境，会在触发 set 的时候判断是否此 key 是否处于 updatingChildren 被修改，如果不是，说明此修改来自子组件，触发 warning 提示。</li></ul> <blockquote><p>需要注意的是，当从子组件修改的 Prop 属于基础类型时会触发提示。这种情况下，是无法修改父组件的数据源的，因为基础类型赋值时是值拷贝。直接将另一个非基础类型（object，array）赋值到此 key 时也会触发提示（但实际上不会影响父组件的数据源），当修改 Object 的属性时不会触发提示，并且会修改父组件数据源的数据。</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/Vue/principle/vnode.html" class="prev">
        Vue3.x 组件的渲染过程
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.2a9e1d26.js" defer></script><script src="/blog/assets/js/2.b5c945b0.js" defer></script><script src="/blog/assets/js/13.61f1338a.js" defer></script>
  </body>
</html>
