(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{340:function(t,a,s){"use strict";s.r(a);var r=s(34),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"动态规划是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态规划是什么"}},[t._v("#")]),t._v(" 动态规划是什么")]),t._v(" "),s("p",[t._v("动态规划是 “算法设计” 中的一种方法")]),t._v(" "),s("p",[t._v("它将一个问题分解为 “相互重叠” 的子问题，通过反复求解子问题，来解决原来的问题。")]),t._v(" "),s("h3",{attrs:{id:"斐波那契数列："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#斐波那契数列："}},[t._v("#")]),t._v(" 斐波那契数列：")]),t._v(" "),s("p",[t._v("0 1 1 2 3 5\n例如第三个 等于 第一个 + 第二个\n定义子问题：F(n) = F(n - 1) + F(n - 2)\n反复执行：从 2 循环到 n ，执行上面的公式")]),t._v(" "),s("h2",{attrs:{id:"动态规划-vs-分而治之"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态规划-vs-分而治之"}},[t._v("#")]),t._v(" 动态规划 VS 分而治之")]),t._v(" "),s("p",[t._v("最大的设计区别看：子问题是否是独立的，如果是“独立的是分而治之”，如果是“相互重叠的是动态规划” 如：上面的斐波那契数列")])])}),[],!1,null,null,null);a.default=n.exports}}]);