(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{402:function(e,t,a){"use strict";a.r(t);var r=a(34),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"虚拟-dom-的工作原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-的工作原理是什么"}},[e._v("#")]),e._v(" 虚拟 DOM 的工作原理是什么")]),e._v(" "),a("p",[e._v("虚拟 DOM 的工作原理是通过 JS 对象模拟 DOM 的节点。在 Facebook 构建 React 初期时，考虑到要提升代码抽象能力、避免人为的 DOM 操作、降低代码整体风险等因素，所以引入了虚拟 DOM。")]),e._v(" "),a("p",[e._v("虚拟 DOM 在实现上通常是 Plain Object，以 React 为例，在 render 函数中写的 JSX 会在 Babel 插件的作用下，编译为 React.createElement 执行 JSX 中的属性参数。")]),e._v(" "),a("p",[e._v("React.createElement 执行后会返回一个 Plain Object，它会描述自己的 tag 类型、props 属性以及 children 情况等。这些 Plain Object 通过树形结构组成一棵虚拟 DOM 树。当状态发生变更时，将变更前后的虚拟 DOM 树进行差异比较，这个过程称为 diff，生成的结果称为 patch。计算之后，会渲染 Patch 完成对真实 DOM 的操作。")]),e._v(" "),a("p",[a("font",{attrs:{color:"red"}},[e._v("虚拟 DOM 的优点")]),e._v("主要有三点：")],1),e._v(" "),a("ol",[a("li",[e._v("改善大规模 DOM 操作的性能、")]),e._v(" "),a("li",[e._v("规避 XSS 风险、")]),e._v(" "),a("li",[e._v("能以较低的成本实现跨平台开发。")])]),e._v(" "),a("p",[a("font",{attrs:{color:"red"}},[e._v("虚拟 DOM 的缺点")]),e._v("在社区中主要有两点:")],1),e._v(" "),a("ol",[a("li",[e._v("内存占用较高，因为需要模拟整个网页的真实 DOM。")]),e._v(" "),a("li",[e._v("高性能应用场景存在难以优化的情况，类似像 Google Earth 一类的高性能前端应用在技术选型上往往不会选择 React。")])]),e._v(" "),a("h3",{attrs:{id:"除了渲染页面，虚拟-dom-还有哪些应用场景？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#除了渲染页面，虚拟-dom-还有哪些应用场景？"}},[e._v("#")]),e._v(" 除了渲染页面，虚拟 DOM 还有哪些应用场景？")]),e._v(" "),a("p",[e._v("这个问题考验面试者的想象力。通常而言，我们只是将虚拟 DOM 与渲染绑定在一起，但实际上虚拟 DOM 的应用更为广阔。比如，只要你记录了真实 DOM 变更，它甚至可以应用于埋点统计与数据记录等。可以往这个方向回答，具体案例可以参考 rrweb。")]),e._v(" "),a("h1",{attrs:{id:"与其它框架相比，react-的-diff-算法有何不同？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与其它框架相比，react-的-diff-算法有何不同？"}},[e._v("#")]),e._v(" 与其它框架相比，React 的 diff 算法有何不同？")]),e._v(" "),a("ul",[a("li",[e._v("diff 算法是什么？\ndiff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。")])]),e._v(" "),a("h3",{attrs:{id:"答题："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#答题："}},[e._v("#")]),e._v(" 答题：")]),e._v(" "),a("p",[e._v("React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。")]),e._v(" "),a("p",[e._v("树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。")]),e._v(" "),a("p",[e._v("组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。")]),e._v(" "),a("p",[e._v("元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。")]),e._v(" "),a("p",[e._v("以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。")]),e._v(" "),a("p",[e._v("整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。")]),e._v(" "),a("p",[e._v("然后拿 Vue 和 Preact 与 React 的 diff 算法进行对比。")]),e._v(" "),a("p",[e._v("Preact 的 Diff 算法相较于 React，整体设计思路相似，但最底层的元素采用了真实 DOM 对比操作，也没有采用 Fiber 设计。Vue 的 Diff 算法整体也与 React 相似，同样未实现 Fiber 设计。")]),e._v(" "),a("p",[e._v("然后进行横向比较，React 拥有完整的 Diff 算法策略，且拥有随时中断更新的时间切片能力，在大批量节点更新的极端情况下，拥有更友好的交互体验。")]),e._v(" "),a("p",[e._v("Preact 可以在一些对性能要求不高，仅需要渲染框架的简单场景下应用。")]),e._v(" "),a("p",[e._v("Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。")]),e._v(" "),a("h3",{attrs:{id:"那如何根据-react-diff-算法原理优化代码呢？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#那如何根据-react-diff-算法原理优化代码呢？"}},[e._v("#")]),e._v(" 那如何根据 React diff 算法原理优化代码呢？")]),e._v(" "),a("p",[e._v("根据 diff 算法的设计原则，应尽量避免跨层级节点移动。")]),e._v(" "),a("p",[e._v("通过设置唯一 key 进行优化，尽量减少组件层级深度。因为过深的层级会加深遍历深度，带来性能问题。")]),e._v(" "),a("p",[e._v("设置 shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数。")])])}),[],!1,null,null,null);t.default=v.exports}}]);